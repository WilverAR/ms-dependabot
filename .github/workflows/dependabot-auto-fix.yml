name: Dependabot Auto Fix

on:
  # Manual trigger to avoid racing Dependabot indexing.
  workflow_dispatch:

concurrency:
  # Prevent overlapping runs for the same branch/ref.
  group: dependabot-auto-fix-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: read

jobs:
  # Job 1: snapshot dependencies and collect open Dependabot alerts.
  dependabot-analyze:
    name: Analyze Alerts And Build Snapshot
    runs-on: ubuntu-latest
    permissions: write-all
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Submit dependency snapshot (Gradle)
        uses: gradle/actions/dependency-submission@v5

      - name: Fetch Dependabot alerts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RENOVATE_TOKEN }}
          script: |
            const fs = require("fs");

            // Read all open alerts using the explicit Dependabot REST endpoint route.
            const alerts = [];
            const perPage = 100;
            let page = 1;
            while (true) {
              const response = await github.request(
                "GET /repos/{owner}/{repo}/dependabot/alerts",
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "open",
                  per_page: perPage,
                  page,
                }
              );
              alerts.push(...response.data);
              if (response.data.length < perPage) break;
              page++;
            }

            // Keep only fields used by the remediation logic.
            const mapped = alerts.map((alert) => {
              const vuln = alert.security_vulnerability || {};
              const pkg = vuln.package || {};
              const patched = vuln.first_patched_version || {};
              const advisory = alert.security_advisory || {};
              return {
                alert_number: alert.number,
                ecosystem: pkg.ecosystem || null,
                name: pkg.name || null,
                fixed_version: patched.identifier || null,
                manifest_path: alert.dependency?.manifest_path || null,
                severity: advisory.severity || null,
              };
            });

            // Store normalized alerts as artifact for the next job.
            fs.writeFileSync("dependabot-alerts.json", JSON.stringify(mapped, null, 2));
            core.info(`Alerts written: ${mapped.length}`);

      - name: Upload alerts artifact
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-auto-fix-alerts-json-${{ github.run_id }}
          path: dependabot-alerts.json

  # Job 2: apply fixes to build.gradle and validate build safety.
  dependabot-auto-fix:
    name: Apply Auto Fixes And Validate Build
    needs: dependabot-analyze
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Print run revision
        run: |
          # Traceability: confirm run SHA equals checked-out HEAD.
          echo "workflow ref: ${{ github.ref }}"
          echo "workflow sha: ${{ github.sha }}"
          git rev-parse HEAD

      - name: Download alerts artifact
        uses: actions/download-artifact@v4
        with:
          name: dependabot-auto-fix-alerts-json-${{ github.run_id }}
          path: .

      - name: Apply vulnerability fixes into build.gradle
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            // Input artifact and target file.
            const alertsPath = "dependabot-alerts.json";
            const buildFile = "build.gradle";

            if (!fs.existsSync(alertsPath)) {
              core.setFailed("dependabot-alerts.json was not found.");
              return;
            }

            // Only Maven alerts with an available fixed version are actionable.
            const alerts = JSON.parse(fs.readFileSync(alertsPath, "utf8"));
            const mavenAlerts = alerts.filter(
              (a) => a?.ecosystem === "maven" && a?.name && a?.fixed_version
            );

            if (!mavenAlerts.length) {
              core.info("No maven alerts with fixed versions. Nothing to remediate.");
              return;
            }

            // Helpers to compare semantic-like versions and to escape regex input.
            const escapeRegex = (v) => v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

            const tokenize = (v) =>
              String(v)
                .split(/[\.-]/)
                .map((p) => (/^\d+$/.test(p) ? Number(p) : p.toLowerCase()));

            const compareVersions = (a, b) => {
              const ta = tokenize(a);
              const tb = tokenize(b);
              const len = Math.max(ta.length, tb.length);
              for (let i = 0; i < len; i++) {
                const va = ta[i] ?? 0;
                const vb = tb[i] ?? 0;
                if (va === vb) continue;
                if (typeof va === "number" && typeof vb === "number") return va - vb;
                return String(va).localeCompare(String(vb));
              }
              return 0;
            };

            // Choose the highest fixed version per package from all alert entries.
            const targetByPackage = new Map();
            for (const alert of mavenAlerts) {
              const current = targetByPackage.get(alert.name);
              if (!current || compareVersions(alert.fixed_version, current) > 0) {
                targetByPackage.set(alert.name, alert.fixed_version);
              }
            }
            // Keep critical families aligned to avoid runtime API mismatches.
            if (targetByPackage.has("ch.qos.logback:logback-core")) {
              const v = targetByPackage.get("ch.qos.logback:logback-core");
              const cur = targetByPackage.get("ch.qos.logback:logback-classic");
              if (!cur || compareVersions(v, cur) > 0) {
                targetByPackage.set("ch.qos.logback:logback-classic", v);
              }
            }
            if (targetByPackage.has("ch.qos.logback:logback-classic")) {
              const v = targetByPackage.get("ch.qos.logback:logback-classic");
              const cur = targetByPackage.get("ch.qos.logback:logback-core");
              if (!cur || compareVersions(v, cur) > 0) {
                targetByPackage.set("ch.qos.logback:logback-core", v);
              }
            }

            if (!fs.existsSync(buildFile)) {
              core.setFailed("build.gradle was not found.");
              return;
            }

            // Apply in-place updates for already-declared dependencies.
            let content = fs.readFileSync(buildFile, "utf8");
            const updates = [];
            const missingPackages = [];

            for (const [pkg, fixedVersion] of targetByPackage.entries()) {
              const refRegex = new RegExp(`(['"])${escapeRegex(pkg)}:[^'"]+\\1`, "g");
              const replacement = `'${pkg}:${fixedVersion}'`;
              if (refRegex.test(content)) {
                content = content.replace(refRegex, replacement);
                updates.push(`${pkg} -> ${fixedVersion} (updated existing reference)`);
              } else {
                missingPackages.push([pkg, fixedVersion]);
              }
            }

            // Utilities to find top-level and nested Gradle blocks by text parsing.
            const findBlockRange = (src, regex, useLast = false) => {
              const matches = [...src.matchAll(regex)];
              if (!matches.length) return null;
              const start = useLast ? matches[matches.length - 1].index : matches[0].index;
              const open = src.indexOf("{", start);
              if (open < 0) return null;
              let depth = 0;
              for (let i = open; i < src.length; i++) {
                const ch = src[i];
                if (ch === "{") depth++;
                if (ch === "}") {
                  depth--;
                  if (depth === 0) return { start, open, end: i };
                }
              }
              return null;
            };

            const findBlockFromStart = (src, start) => {
              const open = src.indexOf("{", start);
              if (open < 0) return null;
              let depth = 0;
              for (let i = open; i < src.length; i++) {
                const ch = src[i];
                if (ch === "{") depth++;
                if (ch === "}") {
                  depth--;
                  if (depth === 0) return { start, open, end: i };
                }
              }
              return null;
            };

            const findBlockInside = (src, outerRange, regex, useLast = false) => {
              if (!outerRange) return null;
              const innerSource = src.slice(outerRange.start, outerRange.end + 1);
              const matches = [...innerSource.matchAll(regex)];
              if (!matches.length) return null;
              const innerStart =
                outerRange.start + (useLast ? matches[matches.length - 1].index : matches[0].index);
              const open = src.indexOf("{", innerStart);
              if (open < 0 || open > outerRange.end) return null;
              let depth = 0;
              for (let i = open; i <= outerRange.end; i++) {
                const ch = src[i];
                if (ch === "{") depth++;
                if (ch === "}") {
                  depth--;
                  if (depth === 0) return { start: innerStart, open, end: i };
                }
              }
              return null;
            };

            const depMgmtRange = findBlockRange(content, /dependencyManagement\s*\{/g);
            const depMgmtImportsRange = findBlockInside(content, depMgmtRange, /imports\s*\{/g);
            const depMgmtDepsRange = findBlockInside(content, depMgmtRange, /dependencies\s*\{/g, true);

            const depMatches = [...content.matchAll(/dependencies\s*\{/g)];
            if (!depMatches.length) {
              core.setFailed("No dependencies block found in build.gradle.");
              return;
            }
            const mainDepCandidates = depMatches.filter((m) => {
              if (!depMgmtRange) return true;
              return m.index < depMgmtRange.start || m.index > depMgmtRange.end;
            });
            const mainDepMatch =
              mainDepCandidates.length > 0
                ? mainDepCandidates[mainDepCandidates.length - 1]
                : depMatches[depMatches.length - 1];
            const mainDepsRange = mainDepMatch ? findBlockFromStart(content, mainDepMatch.index) : null;

            if (missingPackages.length && !mainDepsRange && !depMgmtDepsRange && !depMgmtImportsRange) {
              core.setFailed("No suitable block found to insert missing dependency fixes.");
              return;
            }

            // Prepare insertion lines for packages not currently declared.
            const importLines = [];
            const depMgmtDepLines = [];
            const mainDepLines = [];

            for (const [pkg, fixedVersion] of missingPackages) {
              const artifact = pkg.split(":")[1] || "";
              const isBom = /(^|-)bom$/i.test(artifact);
              if (isBom && depMgmtImportsRange) {
                importLines.push(`\t\tmavenBom '${pkg}:${fixedVersion}'`);
                updates.push(`${pkg} -> ${fixedVersion} (added to dependencyManagement.imports)`);
              } else if (depMgmtDepsRange) {
                depMgmtDepLines.push(`\t\tdependency '${pkg}:${fixedVersion}'`);
                updates.push(`${pkg} -> ${fixedVersion} (added to dependencyManagement.dependencies)`);
              } else if (mainDepsRange) {
                mainDepLines.push(`\timplementation '${pkg}:${fixedVersion}'`);
                updates.push(`${pkg} -> ${fixedVersion} (added to dependencies)`);
              }
            }

            // Insert from the end of file backwards to keep indexes stable.
            const insertions = [];
            if (depMgmtImportsRange && importLines.length) {
              insertions.push({ idx: depMgmtImportsRange.end, text: `\n${importLines.join("\n")}\n` });
            }
            if (depMgmtDepsRange && depMgmtDepLines.length) {
              insertions.push({ idx: depMgmtDepsRange.end, text: `\n${depMgmtDepLines.join("\n")}\n` });
            }
            if (mainDepsRange && mainDepLines.length) {
              insertions.push({ idx: mainDepsRange.end, text: `\n${mainDepLines.join("\n")}\n` });
            }

            insertions
              .sort((a, b) => b.idx - a.idx)
              .forEach((entry) => {
                content = content.slice(0, entry.idx) + entry.text + content.slice(entry.idx);
              });

            // Persist output files for inspection and later PR creation.
            fs.writeFileSync(buildFile, content, "utf8");
            fs.writeFileSync("remediation-summary.txt", updates.join("\n") + "\n", "utf8");
            core.info(`Remediation applied for ${targetByPackage.size} package(s).`);

      - name: Create remediation patch artifact
        if: always()
        run: |
          git diff -- build.gradle > dependabot-auto-fix.patch

      - name: Upload remediation artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-auto-fix-results-${{ github.run_id }}
          path: |
            build.gradle
            dependabot-auto-fix.patch
            remediation-summary.txt

      - name: Validate remediated build
        id: validate
        continue-on-error: true
        run: |
          # Validation runs after artifacts are uploaded so failures are debuggable.
          chmod +x ./gradlew
          ./gradlew clean test

      - name: Fail when remediation is not build-safe
        if: steps.validate.outcome != 'success'
        run: |
          echo "Auto-fix produced an invalid build. Check dependabot-auto-fix artifact."
          exit 1
