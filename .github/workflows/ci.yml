name: CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

permissions:
  contents: read
  security-events: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"
          cache: "gradle"

      - name: Build
        run: |
          chmod +x ./gradlew
          ./gradlew clean build

      - name: Install dependencies
        run: |
          ./gradlew dependencies

      - name: Spring Boot run (smoke)
        run: |
          timeout 60 ./gradlew bootRun || true

  dependabot-analyze:
    needs: build
    runs-on: ubuntu-latest
    permissions: write-all
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Submit dependency snapshot (Gradle)
        uses: gradle/actions/dependency-submission@v5

      - name: Fetch Dependabot alerts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.RENOVATE_TOKEN }}
          script: |
            const fs = require("fs");

            const alerts = await github.paginate(
              github.rest.dependabot.listAlertsForRepo,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: "open",
                per_page: 100,
              }
            );

            const mapped = alerts.map((alert) => {
              const vuln = alert.security_vulnerability || {};
              const pkg = vuln.package || {};
              const patched = vuln.first_patched_version || {};
              const advisory = alert.security_advisory || {};
              return {
                alert_number: alert.number,
                ecosystem: pkg.ecosystem || null,
                name: pkg.name || null,
                fixed_version: patched.identifier || null,
                manifest_path: alert.dependency?.manifest_path || null,
                severity: advisory.severity || null,
              };
            });

            fs.writeFileSync("dependabot-alerts.json", JSON.stringify(mapped, null, 2));
            core.info(`Alerts written: ${mapped.length}`);

      - name: Upload alerts artifact
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-alerts
          path: dependabot-alerts.json

  dependabot-remediate:
    needs: dependabot-analyze
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download alerts artifact
        uses: actions/download-artifact@v4
        with:
          name: dependabot-alerts
          path: .

      - name: Apply vulnerability fixes into build.gradle
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const alertsPath = "dependabot-alerts.json";
            const buildFile = "build.gradle";

            if (!fs.existsSync(alertsPath)) {
              core.setFailed("dependabot-alerts.json was not found.");
              return;
            }

            const alerts = JSON.parse(fs.readFileSync(alertsPath, "utf8"));
            const mavenAlerts = alerts.filter(
              (a) => a?.ecosystem === "maven" && a?.name && a?.fixed_version
            );

            if (!mavenAlerts.length) {
              core.info("No maven alerts with fixed versions. Nothing to remediate.");
              return;
            }

            const escapeRegex = (v) => v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

            const tokenize = (v) =>
              String(v)
                .split(/[\.-]/)
                .map((p) => (/^\d+$/.test(p) ? Number(p) : p.toLowerCase()));

            const compareVersions = (a, b) => {
              const ta = tokenize(a);
              const tb = tokenize(b);
              const len = Math.max(ta.length, tb.length);
              for (let i = 0; i < len; i++) {
                const va = ta[i] ?? 0;
                const vb = tb[i] ?? 0;
                if (va === vb) continue;
                if (typeof va === "number" && typeof vb === "number") return va - vb;
                return String(va).localeCompare(String(vb));
              }
              return 0;
            };

            const targetByPackage = new Map();
            for (const alert of mavenAlerts) {
              const current = targetByPackage.get(alert.name);
              if (!current || compareVersions(alert.fixed_version, current) > 0) {
                targetByPackage.set(alert.name, alert.fixed_version);
              }
            }

            if (!fs.existsSync(buildFile)) {
              core.setFailed("build.gradle was not found.");
              return;
            }

            let content = fs.readFileSync(buildFile, "utf8");
            const updates = [];
            const missingPackages = [];

            for (const [pkg, fixedVersion] of targetByPackage.entries()) {
              const refRegex = new RegExp(`(['"])${escapeRegex(pkg)}:[^'"]+\\1`, "g");
              const replacement = `'${pkg}:${fixedVersion}'`;
              if (refRegex.test(content)) {
                content = content.replace(refRegex, replacement);
                updates.push(`${pkg} -> ${fixedVersion} (updated existing reference)`);
              } else {
                missingPackages.push([pkg, fixedVersion]);
              }
            }

            const findBlockRange = (src, regex, useLast = false) => {
              const matches = [...src.matchAll(regex)];
              if (!matches.length) return null;
              const start = useLast ? matches[matches.length - 1].index : matches[0].index;
              const open = src.indexOf("{", start);
              if (open < 0) return null;
              let depth = 0;
              for (let i = open; i < src.length; i++) {
                const ch = src[i];
                if (ch === "{") depth++;
                if (ch === "}") {
                  depth--;
                  if (depth === 0) return { start, open, end: i };
                }
              }
              return null;
            };

            const findBlockFromStart = (src, start) => {
              const open = src.indexOf("{", start);
              if (open < 0) return null;
              let depth = 0;
              for (let i = open; i < src.length; i++) {
                const ch = src[i];
                if (ch === "{") depth++;
                if (ch === "}") {
                  depth--;
                  if (depth === 0) return { start, open, end: i };
                }
              }
              return null;
            };

            const findBlockInside = (src, outerRange, regex, useLast = false) => {
              if (!outerRange) return null;
              const innerSource = src.slice(outerRange.start, outerRange.end + 1);
              const matches = [...innerSource.matchAll(regex)];
              if (!matches.length) return null;
              const innerStart =
                outerRange.start + (useLast ? matches[matches.length - 1].index : matches[0].index);
              const open = src.indexOf("{", innerStart);
              if (open < 0 || open > outerRange.end) return null;
              let depth = 0;
              for (let i = open; i <= outerRange.end; i++) {
                const ch = src[i];
                if (ch === "{") depth++;
                if (ch === "}") {
                  depth--;
                  if (depth === 0) return { start: innerStart, open, end: i };
                }
              }
              return null;
            };

            const depMgmtRange = findBlockRange(content, /dependencyManagement\s*\{/g);
            const depMgmtImportsRange = findBlockInside(content, depMgmtRange, /imports\s*\{/g);
            const depMgmtDepsRange = findBlockInside(content, depMgmtRange, /dependencies\s*\{/g, true);

            const depMatches = [...content.matchAll(/dependencies\s*\{/g)];
            const mainDepCandidates = depMatches.filter((m) => {
              if (!depMgmtRange) return true;
              return m.index < depMgmtRange.start || m.index > depMgmtRange.end;
            });
            const mainDepMatch =
              mainDepCandidates.length > 0
                ? mainDepCandidates[mainDepCandidates.length - 1]
                : depMatches[depMatches.length - 1];
            const mainDepsRange = mainDepMatch ? findBlockFromStart(content, mainDepMatch.index) : null;

            if (missingPackages.length && !mainDepsRange && !depMgmtDepsRange && !depMgmtImportsRange) {
              core.setFailed("No suitable block found to insert missing dependency fixes.");
              return;
            }

            const importLines = [];
            const depMgmtDepLines = [];
            const mainDepLines = [];

            for (const [pkg, fixedVersion] of missingPackages) {
              const artifact = pkg.split(":")[1] || "";
              const isBom = /(^|-)bom$/i.test(artifact);
              if (isBom && depMgmtImportsRange) {
                importLines.push(`\t\tmavenBom '${pkg}:${fixedVersion}'`);
                updates.push(`${pkg} -> ${fixedVersion} (added to dependencyManagement.imports)`);
              } else if (depMgmtDepsRange) {
                depMgmtDepLines.push(`\t\tdependency '${pkg}:${fixedVersion}'`);
                updates.push(`${pkg} -> ${fixedVersion} (added to dependencyManagement.dependencies)`);
              } else if (mainDepsRange) {
                mainDepLines.push(`\timplementation '${pkg}:${fixedVersion}'`);
                updates.push(`${pkg} -> ${fixedVersion} (added to dependencies)`);
              }
            }

            const insertions = [];
            if (depMgmtImportsRange && importLines.length) {
              insertions.push({ idx: depMgmtImportsRange.end, text: `\n${importLines.join("\n")}\n` });
            }
            if (depMgmtDepsRange && depMgmtDepLines.length) {
              insertions.push({ idx: depMgmtDepsRange.end, text: `\n${depMgmtDepLines.join("\n")}\n` });
            }
            if (mainDepsRange && mainDepLines.length) {
              insertions.push({ idx: mainDepsRange.end, text: `\n${mainDepLines.join("\n")}\n` });
            }

            insertions
              .sort((a, b) => b.idx - a.idx)
              .forEach((entry) => {
                content = content.slice(0, entry.idx) + entry.text + content.slice(entry.idx);
              });

            fs.writeFileSync(buildFile, content, "utf8");
            fs.writeFileSync("remediation-summary.txt", updates.join("\n") + "\n", "utf8");
            core.info(`Remediation applied for ${targetByPackage.size} package(s).`);

      - name: Create remediation patch artifact
        run: |
          git diff -- build.gradle > dependabot-remediation.patch

      - name: Upload remediation artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dependabot-remediation
          path: |
            build.gradle
            dependabot-remediation.patch
            remediation-summary.txt

